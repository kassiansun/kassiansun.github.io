<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Go on Kassian Sun</title><link>https://blog.kassiansun.com/tags/go/</link><description>Recent content in Go on Kassian Sun</description><generator>Hugo -- 0.128.2</generator><language>en</language><lastBuildDate>Wed, 23 Nov 2022 16:51:25 +0800</lastBuildDate><atom:link href="https://blog.kassiansun.com/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Runtime Implementations: Map</title><link>https://blog.kassiansun.com/posts/go-source-code-part-19/</link><pubDate>Wed, 23 Nov 2022 16:51:25 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-19/</guid><description>Code Path: src/runtime/map.go makemap Each hmap has a hash0 as seed hash. When the compiler generates the typing information for a map, the hasher function will be calculated with genhash function (code path: src/cmd/compile/internal/reflectdata/alg.go).
If the map is not escaped, the hmap will be allocated by the compiler on the stack.
Then makemap will allocate an array of bucket, the type of bucket is generated at compiling stage by MapBucketType (code path: src/cmd/compile/internal/reflectdata/reflect.</description></item><item><title>Go Runtime Implementations: Timer Scheduling</title><link>https://blog.kassiansun.com/posts/go-source-code-part-18/</link><pubDate>Mon, 07 Nov 2022 08:49:37 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-18/</guid><description>Code Path: src/runtime/time.go time.startTimer (implemented as addtimer) Each p has a timers list. When a user is adding a new timer, it will first try to clean up the timers list, then adds the new timer. Each timers list is a heap sorted by timer.when, and will be updated during add/delete timers.
cleantimers cleantimers only checks the head of the timers list.
Check if it&amp;rsquo;s timerDeleted, delete it from the timers list, and update p&amp;rsquo;s timer0When.</description></item><item><title>Go Runtime Implementations: Network Polling</title><link>https://blog.kassiansun.com/posts/go-source-code-part-17/</link><pubDate>Sat, 05 Nov 2022 08:56:11 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-17/</guid><description>Code Path: src/runtime/netpoll.go Network polling is platform-dependent, the following is of BSD family operating systems (based on kqueue).
netpollinit Initialize a kqueue descriptor, and set CLOSEXEC flag on it. Initialize a non-blocking pipe, and use the reader/writer for netpollBreak. netpollBreak will try to write to the pipe and interrupt the kevent. netpoll netpoll is used to check the connections and return a list of g ready to run. It can block for delay ns at most.</description></item><item><title>Go Runtime Implementations: Select</title><link>https://blog.kassiansun.com/posts/go-source-code-part-16/</link><pubDate>Fri, 04 Nov 2022 14:14:30 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-16/</guid><description>Code Path: src/runtime/select.go IR stage IR will walk a select statement and generate the code accordingly:
If there&amp;rsquo;s no case, replace the select statement with runtime.block, the current goroutine will be blocked forever. If there&amp;rsquo;s only one case, extract the send or receive operation from the case statement. Otherwise, convert case values to addresses. If there&amp;rsquo;s only one case with one default, replace it with non-block calls selectnbsend or selectnbrecv.</description></item><item><title>Go Runtime Implementations: Slices</title><link>https://blog.kassiansun.com/posts/go-source-code-part-15/</link><pubDate>Fri, 04 Nov 2022 09:21:06 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-15/</guid><description>Code Path: src/runtime/slice.go makeslicecopy makeslicecopy is used for IR patterns like m = OMAKESLICE([]T, x); OCOPY(m, s), IR will rewrite this specific order of code path and replace it with OMAKESLICECOPY. If the elements has no pointer, SSA will generate code to do a mallocgc and memmove. Otherwise, the code will be expanded to makeslicecopy:
Check the length of the slice to copy to. Do mallocgc Do memmove makeslice and `makeslice641 makeslice is used for make(slice, len, cap) statements, if cap is missing, by default it will be the same as len.</description></item><item><title>Go Runtime Implementations: Interfaces</title><link>https://blog.kassiansun.com/posts/go-source-code-part-14/</link><pubDate>Thu, 27 Oct 2022 10:16:17 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-14/</guid><description>Static Definition and Initialization Code Path: src/runtime/iface.go In proc.go, itabsinit will init the itabTable with the current activeModules information. The itabsinit function will read the itablinks from each module and add them to the global hash table.
During the runtime, the getitab function will also build more items dynamically and fill the hash table accordingly.
itablinks was produced for each module during the linking stage, and contains an array of itab.</description></item><item><title>Go Runtime Implementations: Typing System</title><link>https://blog.kassiansun.com/posts/go-source-code-part-13/</link><pubDate>Tue, 25 Oct 2022 17:59:51 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-13/</guid><description>Compiling Code Path: src/cmd/compile/internal/ir/expr.go During the IR stage, each expression will get type info, it&amp;rsquo;s defined as miniExpr and can be assigned a types.Type value.
Static Typing: types2 Code Path: src/cmd/compile/internal/types2 types and `types2 Conversion Code Path: src/cmd/compile/internal/noder/types.go Currently, both packages are in use, but much logic is being migrated to types2 package. types2 package was introduced as part of go generic features and has a better code structure than the old types package.</description></item><item><title>Go Runtime Implementations: Garbage Collection</title><link>https://blog.kassiansun.com/posts/go-source-code-part-11/</link><pubDate>Tue, 18 Oct 2022 14:17:39 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-11/</guid><description>Ref Garbage Collector Code Path: src/runtime/mgc.go gcinit gcinit runs after almost everything set up in schedinit.
Set sweepDrainedMask Initialize gcController with GOGC (for GC percentage control) and GOMEMLIMIT (for memory limits). Initialize work semaphores. gcenable gcenable happens in the main goroutine, right after runtime_inittask.
Start bgsweep Start bgscavenge GC GC runs a full garbage collection. Each run will finish the current GC cycle: sweep termination, mark, mark termination, and sweep.</description></item><item><title>Go Runtime Implementations: Stack and Memory Management</title><link>https://blog.kassiansun.com/posts/go-source-code-part-10/</link><pubDate>Sun, 16 Oct 2022 15:48:13 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-10/</guid><description>Stack Management Code Path: src/runtime/stack.go Stack pools are initialized before mheap_, because we don&amp;rsquo;t allocate any memory during this stage. Right after the stack pools initialized, the mheap_ will be initialized so later stack allocation is possible.
stackpool stackpool is managed by the &amp;ldquo;order&amp;rdquo; (based on the ratio of stack size and _FixedStack) of the stack, each order of stack has its own stack pool. In stackinit, the stack pool will be initialized right after moduledataverify.</description></item><item><title>Go Runtime Implementations: Scheduling</title><link>https://blog.kassiansun.com/posts/go-source-code-part-9/</link><pubDate>Fri, 14 Oct 2022 18:31:51 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-9/</guid><description>Code Path: src/runtime/proc.go Start-Up Process of a Go program. Take src/runtime/asm_arm.s as an example:
Take the address of g0 and m0. Set up m.g0 and g.m. Create istack. Do runtime check. Save argc and argv. Call runtime.osinit. Call runtime.schedinit. Call runtime.newproc for the main function. call runtime.mstart to start the M. runtime.osinit Take src/runtime/os_linux.go as an example:
Get the number of processors. This is done by making a syscall SYS_sched_getaffinity.</description></item><item><title>Go Runtime Implementations: Goroutines</title><link>https://blog.kassiansun.com/posts/go-source-code-part-8/</link><pubDate>Wed, 12 Oct 2022 14:42:48 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-8/</guid><description>Preface Code path: src/runtime/proc.go Data structures are defined under src/runtime/runtime2.go. Concepts Copied from source code:
// G - goroutine. // M - worker thread, or machine. // P - processor, a resource that is required to execute Go code. // M must have an associated P to execute Go code, however it can be // blocked or in a syscall w/o an associated P. main Set up stack size. Fork a new m and run the sysmon function, except the wasm platform.</description></item><item><title>Go Runtime Implementations: Channel</title><link>https://blog.kassiansun.com/posts/go-source-code-part-7/</link><pubDate>Thu, 29 Sep 2022 11:24:26 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-7/</guid><description>Path: src/runtime/chan.go Compilation When you make a chan with make function, the compiler will expand the expression to the makechan implementation. The actual expansion happens at cmd/compile/internal/walk/expr.go. The runtime will determine whether to use makechan or makechan64.
Type Definitions type _type _type is used as the internal representation of a go type. The same structure is defined multiple times across the go runtime. _type stores the following fields:
type chantype makechan only uses chantype.</description></item><item><title>Travesal Through The Go Compiler, Part 6</title><link>https://blog.kassiansun.com/posts/go-source-code-part-6/</link><pubDate>Tue, 20 Sep 2022 10:39:15 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-6/</guid><description>ssagen.Compile Build SSA for the ir.Func (buildssa) Check ssaDump and set the dump flag. Initialize ssagen.state. Push the line number or the parent&amp;rsquo;s line number (if it&amp;rsquo;s missing) to the stack. Set up ssagen.state flags from ir.Func information. Set up an empty ssagen.ssafn with ir.Func and ABI information. Allocate the starting block for the current ssa.Func. Check open-coded defers. &amp;lt;- What&amp;rsquo;s this? Do ABIAnalyze, get the abi.ABIParamResultInfo of function in/out parameters.</description></item><item><title>Travesal Through The Go Compiler, Part 5</title><link>https://blog.kassiansun.com/posts/go-source-code-part-5/</link><pubDate>Mon, 19 Sep 2022 10:54:34 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-5/</guid><description>irgen.generate Check each file&amp;rsquo;s pragma list and DeclList. Generate ir.Decl for type declarations. Generate ir.Decl for other declarations. Process later functions, this step is for the same purpose as type check. Type-check CallExpr again. Check missing function bodies. Build generic instantiations. It scans calls and generated needed methods. Remove all generic Decl&amp;rsquo;s. After irgen.generate, g.target.Decls will be the final Decl&amp;rsquo;s to generate.
enqueueFunc and compileFunctions This step is the compile step of cmd/compile, it happens after type checking and IR generation.</description></item><item><title>Travesal Through The Go Compiler, Part 4</title><link>https://blog.kassiansun.com/posts/go-source-code-part-4/</link><pubDate>Sun, 18 Sep 2022 14:09:58 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-4/</guid><description>noder.LoadPackage Parsing noder.LoadPackage will call syntax.Parse to generate the syntax tree of all package files.
Initialize a compile/internal/syntax.scanner Advance scanner to the next token. Start parsing. Check the package declaration first, and take the package name from the parsed pragma. Note that the parser is expecting a ; token, but this is automatically generated at the scanner, so users don&amp;rsquo;t have to write the ;. And parsing errors will not always abort the parser loop.</description></item><item><title>Travesal Through The Go Compiler, Part 3</title><link>https://blog.kassiansun.com/posts/go-source-code-part-3/</link><pubDate>Sat, 17 Sep 2022 09:29:52 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-3/</guid><description>BuildToolchain BuildToolchain is initialized as noToolchain{} by default, then it&amp;rsquo;s set dynamically to gccgo or gc. Both implementations are wrappers around the binary toolchains installed on the machine. For gc, the delegations are as follows:
BuildToolchain.gc - base.Tool(&amp;quot;compile&amp;quot;) BuildToolchain.cc - base.Tool(&amp;quot;cgo&amp;quot;). Actually cgo has been executed before the compile and cfiles has been cleared, so BuildToolchain.cc should never be called and it always returns an error. BuildToolchain.asm - base.Tool(&amp;quot;asm&amp;quot;) BuildToolchain.pack - base.</description></item><item><title>Travesal Through The Go Compiler, Part 2</title><link>https://blog.kassiansun.com/posts/go-source-code-part-2/</link><pubDate>Fri, 16 Sep 2022 15:16:23 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-2/</guid><description>Builder.build Builder.build generate an archive for a single package.
Builder.build gets building information from two sources: internal/cfg package. It contains some global variables saving build flags. load.Package. It contains information for the current building package. Builder.build will build a need flag, finish the step and uncheck the finished bits one by one. Set up caching information by action, its package, and package&amp;rsquo;s target. Set up objects output directory. Setup cgo cache &amp;amp; vet cache.</description></item><item><title>Traversal Through The Go Compiler, Part 1</title><link>https://blog.kassiansun.com/posts/go-source-code-part-1/</link><pubDate>Thu, 15 Sep 2022 08:48:31 +0800</pubDate><guid>https://blog.kassiansun.com/posts/go-source-code-part-1/</guid><description>Set Up the Environment vim-go doesn&amp;rsquo;t support travesal through the go source code, so I switch to vscode and it works out of box (with Go plugin &amp;amp;&amp;amp; gopls installed).
Start Point (go run) File: src/cmd/go/main.go Declaration: run.CmdRun Function: run.runRun Key data structures: build.Context work.Builder load.Package work.Action The runRun function will go through several stages:
Check shouldUseOutsideModuleMode. This procedure is used by go run cmd@version work.BuildInit. This will setup the build context: Initialize modload module.</description></item></channel></rss>