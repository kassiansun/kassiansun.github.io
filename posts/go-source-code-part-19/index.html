<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go Runtime Implementations: Map | Kassian Sun</title>
<meta name=keywords content="go"><meta name=description content="
Code Path: src/runtime/map.go

makemap
Each hmap has a hash0 as seed hash. When the compiler generates the typing information for a map, the hasher
function will be calculated with genhash function (code path: src/cmd/compile/internal/reflectdata/alg.go).
If the map is not escaped, the hmap will be allocated by the compiler on the stack.
Then makemap will allocate an array of bucket, the type of bucket is generated at compiling stage by MapBucketType
(code path: src/cmd/compile/internal/reflectdata/reflect.go)."><meta name=author content><link rel=canonical href=https://blog.kassiansun.com/posts/go-source-code-part-19/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.kassiansun.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.kassiansun.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.kassiansun.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.kassiansun.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.kassiansun.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.kassiansun.com/posts/go-source-code-part-19/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-0NC5Q6H2ZC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-0NC5Q6H2ZC")}</script><meta property="og:title" content="Go Runtime Implementations: Map"><meta property="og:description" content="
Code Path: src/runtime/map.go

makemap
Each hmap has a hash0 as seed hash. When the compiler generates the typing information for a map, the hasher
function will be calculated with genhash function (code path: src/cmd/compile/internal/reflectdata/alg.go).
If the map is not escaped, the hmap will be allocated by the compiler on the stack.
Then makemap will allocate an array of bucket, the type of bucket is generated at compiling stage by MapBucketType
(code path: src/cmd/compile/internal/reflectdata/reflect.go)."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.kassiansun.com/posts/go-source-code-part-19/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-23T16:51:25+08:00"><meta property="article:modified_time" content="2022-11-23T16:51:25+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go Runtime Implementations: Map"><meta name=twitter:description content="
Code Path: src/runtime/map.go

makemap
Each hmap has a hash0 as seed hash. When the compiler generates the typing information for a map, the hasher
function will be calculated with genhash function (code path: src/cmd/compile/internal/reflectdata/alg.go).
If the map is not escaped, the hmap will be allocated by the compiler on the stack.
Then makemap will allocate an array of bucket, the type of bucket is generated at compiling stage by MapBucketType
(code path: src/cmd/compile/internal/reflectdata/reflect.go)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.kassiansun.com/posts/"},{"@type":"ListItem","position":2,"name":"Go Runtime Implementations: Map","item":"https://blog.kassiansun.com/posts/go-source-code-part-19/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go Runtime Implementations: Map","name":"Go Runtime Implementations: Map","description":" Code Path: src/runtime/map.go makemap Each hmap has a hash0 as seed hash. When the compiler generates the typing information for a map, the hasher function will be calculated with genhash function (code path: src/cmd/compile/internal/reflectdata/alg.go).\nIf the map is not escaped, the hmap will be allocated by the compiler on the stack.\nThen makemap will allocate an array of bucket, the type of bucket is generated at compiling stage by MapBucketType (code path: src/cmd/compile/internal/reflectdata/reflect.go).\n","keywords":["go"],"articleBody":" Code Path: src/runtime/map.go makemap Each hmap has a hash0 as seed hash. When the compiler generates the typing information for a map, the hasher function will be calculated with genhash function (code path: src/cmd/compile/internal/reflectdata/alg.go).\nIf the map is not escaped, the hmap will be allocated by the compiler on the stack.\nThen makemap will allocate an array of bucket, the type of bucket is generated at compiling stage by MapBucketType (code path: src/cmd/compile/internal/reflectdata/reflect.go).\nWhen the map is growing, there will be two different buckets, one is for storing the old data and one is for storing the new data.\nmapdelete mapdelete is used to delete a key from the hmap. All modifications to a map will mark the flags with hashWriting. Before map modifications, we’ll try to evacuate the elements from the old buckets.\nNote that a for-loop to delete all map keys is optimized as a mapclear call by the compiler. An empty map will reset its hash0 after the last element deleted.\nmapaccess When trying to access a map, mapaccess will check the flags for concurrent writing, and dynamically switch the destination based on whether the corresponding bucket has been evacuated. Then mapaccess will iterate the bucket to find the key.\nmapiterinit The hiter struct is a snapshot of the current status of the map, so even though the map grew later, the iterator can point to the correct underlying data.\nmapassign mapassign will find the bucket for the specified key, and return an address to save the value.\nhashGrow hashGrow happens when the the map is too full. It will grow by either doubling the buckets, or do a same-size growing. Whether it’s a same-size growing will determine whether we should use the current B value as an indicator of bucket size or B - 1,\nThe hashing logic doesn’t change after a hash growing, but the hask masking will change, so if we don’t track the growing strategy, it’s impossible to evacuate data from the oldbuckets to the buckets correctly.\nIf the buckets are full, there’ll be some extra buckets chained behind it to save the overflowed elements.\n","wordCount":"352","inLanguage":"en","datePublished":"2022-11-23T16:51:25+08:00","dateModified":"2022-11-23T16:51:25+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.kassiansun.com/posts/go-source-code-part-19/"},"publisher":{"@type":"Organization","name":"Kassian Sun","logo":{"@type":"ImageObject","url":"https://blog.kassiansun.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.kassiansun.com/ accesskey=h title="Kassian Sun (Alt + H)">Kassian Sun</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.kassiansun.com/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Go Runtime Implementations: Map</h1><div class=post-meta><span title='2022-11-23 16:51:25 +0800 +0800'>November 23, 2022</span></div></header><div class=post-content><ul><li>Code Path: <code>src/runtime/map.go</code></li></ul><h2 id=makemap><code>makemap</code><a hidden class=anchor aria-hidden=true href=#makemap>#</a></h2><p>Each <code>hmap</code> has a <code>hash0</code> as seed hash. When the compiler generates the typing information for a map, the <code>hasher</code>
function will be calculated with <code>genhash</code> function (code path: <code>src/cmd/compile/internal/reflectdata/alg.go</code>).</p><p>If the map is not escaped, the <code>hmap</code> will be allocated by the compiler on the stack.</p><p>Then <code>makemap</code> will allocate an array of <code>bucket</code>, the type of <code>bucket</code> is generated at compiling stage by <code>MapBucketType</code>
(code path: <code>src/cmd/compile/internal/reflectdata/reflect.go</code>).</p><p>When the map is growing, there will be two different buckets, one is for storing the old data and one is for storing the new data.</p><h2 id=mapdelete><code>mapdelete</code><a hidden class=anchor aria-hidden=true href=#mapdelete>#</a></h2><p><code>mapdelete</code> is used to delete a key from the <code>hmap</code>. All modifications to a map will mark the <code>flags</code> with <code>hashWriting</code>.
Before map modifications, we&rsquo;ll try to <code>evacuate</code> the elements from the old buckets.</p><p>Note that a for-loop to delete all map keys is optimized as a <code>mapclear</code> call by the compiler.
An empty map will reset its <code>hash0</code> after the last element deleted.</p><h2 id=mapaccess><code>mapaccess</code><a hidden class=anchor aria-hidden=true href=#mapaccess>#</a></h2><p>When trying to access a map, <code>mapaccess</code> will check the <code>flags</code> for concurrent writing, and dynamically switch the destination based
on whether the corresponding bucket has been evacuated. Then <code>mapaccess</code> will iterate the bucket to find the key.</p><h2 id=mapiterinit><code>mapiterinit</code><a hidden class=anchor aria-hidden=true href=#mapiterinit>#</a></h2><p>The <code>hiter</code> struct is a snapshot of the current status of the map, so even though the map grew later, the iterator can point to the
correct underlying data.</p><h2 id=mapassign><code>mapassign</code><a hidden class=anchor aria-hidden=true href=#mapassign>#</a></h2><p><code>mapassign</code> will find the bucket for the specified key, and return an address to save the value.</p><h3 id=hashgrow><code>hashGrow</code><a hidden class=anchor aria-hidden=true href=#hashgrow>#</a></h3><p>hashGrow happens when the the map is too full. It will grow by either doubling the buckets, or do a same-size growing.
Whether it&rsquo;s a same-size growing will determine whether we should use the current <code>B</code> value as an indicator of bucket size or <code>B - 1</code>,</p><p>The hashing logic doesn&rsquo;t change after a hash growing, but the hask masking will change, so if we don&rsquo;t track the growing strategy,
it&rsquo;s impossible to <code>evacuate</code> data from the <code>oldbuckets</code> to the <code>buckets</code> correctly.</p><p>If the buckets are full, there&rsquo;ll be some extra buckets chained behind it to save the overflowed elements.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.kassiansun.com/tags/go/>Go</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.kassiansun.com/>Kassian Sun</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>