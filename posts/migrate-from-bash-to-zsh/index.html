<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Migrate From Bash to Zsh | Kassian Sun</title>
<meta name=keywords content="development,terminal"><meta name=description content="The story of bash and my taste on command line I&rsquo;ve been using bash as the development environment for a long time. The reason for choosing bash is its ubiquity. Most desktop & server Linux distributions and Docker images will ship with bash, which makes it a great fit for a configure-once-use-everywhere development environment. So you write it once and copy it to every host you&rsquo;ll write code on. But since ~2014 my bash configuration has degraded several times, for two major reasons:"><meta name=author content><link rel=canonical href=https://blog.kassiansun.com/posts/migrate-from-bash-to-zsh/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.kassiansun.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.kassiansun.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.kassiansun.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.kassiansun.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.kassiansun.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.kassiansun.com/posts/migrate-from-bash-to-zsh/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-E9FSQ1R0HV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-E9FSQ1R0HV")}</script><meta property="og:title" content="Migrate From Bash to Zsh"><meta property="og:description" content="The story of bash and my taste on command line I&rsquo;ve been using bash as the development environment for a long time. The reason for choosing bash is its ubiquity. Most desktop & server Linux distributions and Docker images will ship with bash, which makes it a great fit for a configure-once-use-everywhere development environment. So you write it once and copy it to every host you&rsquo;ll write code on. But since ~2014 my bash configuration has degraded several times, for two major reasons:"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.kassiansun.com/posts/migrate-from-bash-to-zsh/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-28T10:14:21+08:00"><meta property="article:modified_time" content="2021-11-28T10:14:21+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Migrate From Bash to Zsh"><meta name=twitter:description content="The story of bash and my taste on command line I&rsquo;ve been using bash as the development environment for a long time. The reason for choosing bash is its ubiquity. Most desktop & server Linux distributions and Docker images will ship with bash, which makes it a great fit for a configure-once-use-everywhere development environment. So you write it once and copy it to every host you&rsquo;ll write code on. But since ~2014 my bash configuration has degraded several times, for two major reasons:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.kassiansun.com/posts/"},{"@type":"ListItem","position":2,"name":"Migrate From Bash to Zsh","item":"https://blog.kassiansun.com/posts/migrate-from-bash-to-zsh/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Migrate From Bash to Zsh","name":"Migrate From Bash to Zsh","description":"The story of bash and my taste on command line I\u0026rsquo;ve been using bash as the development environment for a long time. The reason for choosing bash is its ubiquity. Most desktop \u0026amp; server Linux distributions and Docker images will ship with bash, which makes it a great fit for a configure-once-use-everywhere development environment. So you write it once and copy it to every host you\u0026rsquo;ll write code on. But since ~2014 my bash configuration has degraded several times, for two major reasons:","keywords":["development","terminal"],"articleBody":"The story of bash and my taste on command line I’ve been using bash as the development environment for a long time. The reason for choosing bash is its ubiquity. Most desktop \u0026 server Linux distributions and Docker images will ship with bash, which makes it a great fit for a configure-once-use-everywhere development environment. So you write it once and copy it to every host you’ll write code on. But since ~2014 my bash configuration has degraded several times, for two major reasons:\nTo support different host environments, from Arch Linux to WSL to Cygwin to Mac OS To support different terminal environments, from XShell/iTerm to putty to the serial console The need for “use-everywhere” decreased my coding productivity for the most time and made the configuration harder and harder to maintain.\nSince 2019 I’ve been a heavy user of Macbook, mainly because every company ships Macbook for programmers by default. My personal machine was always XPS13, hosting a Windows + Hyper-V + ArchLinux environment, and using a standard bash environment on ArchLinux, ssh-ed with XShell. The pros of this configuration:\nArch Linux is the most easy-to-use distribution, with rolling updates and a simple packaging strategy. XShell provides a decent good terminal experience. Windows is the most widespread desktop operating system. The cons are quite obvious: it’s hard to configure and hard to port, you need to bring up a brand-new Arch Linux virtual machine on every new host (the development environment is too big to copy and paste).\nOn the other hand, Mac OS ships with a shell environment by default, and everything in it is Unix-like. Along with homebrew, the command line environment feels good enough, although not comparable with the pureness of Arch Linux. The hardware of Mac OS was always a pain point, but not anymore with the M1 chip. Earlier this year I purchased an M1 Macbook, after daily usages of more than half a year, I decided to boost my productivity on Mac OS to maximum, which means the productivity on command line.\nThe good parts of oh-my-zsh and why it was successful I’ve heard of oh-my-zsh for several years, zsh is not a ubiquity shell, but since I’ve decided to give up on the “use-everywhere” feature, it’s not a problem anymore. After one-week experience with oh-my-zsh, there’re several points I’ve noticed:\nThe basic shell support is similar, which makes porting the old .bash_profile very easy. The default configuration of oh-my-zsh is good enough, so I don’t have to worry about the initial learning curve. The ecosystem (mainly plugins) was a key to success. The vi-mode plugin works great, as a heavy user of vim, this boosts my keystrokes a lot. Support django by default, and I’m learning it to build a backend API server for my personal project. History is synchronized across different terminals, especially useful as I’m always using a lot of tabs for different purposes. All of these advantages make oh-my-zsh a safe suggestion for newbie programmers. It’s neither exotic nor bizarre, it’s a decent good starting point and everything you learned with it will be useful later.\nSome pain points as a former bash user git plugin shiped by default pollutes the command line with a super long list of git shortcuts, as a heavy user of .gitconfig, it’s useless and confusing. git has a default integration with oh-my-zsh, you need to turn it off. First noticed this when I cd into the WebKit repository and zsh were stuck on it. The completion doesn’t always work, many packages don’t ship with zsh completion by default. The tab behavior feels very different from bash, I’m still getting used to it. History across terminals is good, but also a bit confusing when I stoke up and see something unexpected. ","wordCount":"627","inLanguage":"en","datePublished":"2021-11-28T10:14:21+08:00","dateModified":"2021-11-28T10:14:21+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.kassiansun.com/posts/migrate-from-bash-to-zsh/"},"publisher":{"@type":"Organization","name":"Kassian Sun","logo":{"@type":"ImageObject","url":"https://blog.kassiansun.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.kassiansun.com/ accesskey=h title="Kassian Sun (Alt + H)">Kassian Sun</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://blog.kassiansun.com/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Migrate From Bash to Zsh</h1><div class=post-meta>&lt;span title='2021-11-28 10:14:21 +0800 +0800'>November 28, 2021&lt;/span></div></header><div class=post-content><h2 id=the-story-of-bash-and-my-taste-on-command-line>The story of bash and my taste on command line<a hidden class=anchor aria-hidden=true href=#the-story-of-bash-and-my-taste-on-command-line>#</a></h2><p>I&rsquo;ve been using <code>bash</code> as the development environment for a long time. The reason for choosing <code>bash</code> is its ubiquity.
Most desktop & server Linux distributions and Docker images will ship with bash, which makes it a great fit for a
configure-once-use-everywhere development environment. So you write it once and copy it to every host you&rsquo;ll write
code on. But since ~2014 my bash configuration has degraded several times, for two major reasons:</p><ol><li>To support different host environments, from Arch Linux to WSL to Cygwin to Mac OS</li><li>To support different terminal environments, from XShell/iTerm to putty to the serial console</li></ol><p>The need for &ldquo;use-everywhere&rdquo; decreased my coding productivity for the most time and made the configuration
harder and harder to maintain.</p><p>Since 2019 I&rsquo;ve been a heavy user of Macbook, mainly because
every company ships Macbook for programmers by default. My personal machine was always XPS13, hosting a
Windows + Hyper-V + ArchLinux environment, and using a standard bash environment on ArchLinux, ssh-ed with XShell.
The pros of this configuration:</p><ol><li>Arch Linux is the most easy-to-use distribution, with rolling updates and a simple packaging strategy.</li><li>XShell provides a decent good terminal experience.</li><li>Windows is the most widespread desktop operating system.</li></ol><p>The cons are quite obvious: it&rsquo;s hard to configure and hard to port, you need to bring up a brand-new
Arch Linux virtual machine on every new host (the development environment is too big to copy and paste).</p><p>On the other hand, Mac OS ships with a shell environment by default, and everything in it is Unix-like.
Along with homebrew, the command line environment feels good enough, although not comparable with the pureness
of Arch Linux. The hardware of Mac OS was always a pain point, but not anymore with the M1 chip. Earlier this year I
purchased an M1 Macbook, after daily usages of more than half a year, I decided to boost my productivity on Mac OS
to maximum, which means the productivity on command line.</p><h2 id=the-good-parts-of-oh-my-zsh-and-why-it-was-successful>The good parts of <code>oh-my-zsh</code> and why it was successful<a hidden class=anchor aria-hidden=true href=#the-good-parts-of-oh-my-zsh-and-why-it-was-successful>#</a></h2><p>I&rsquo;ve heard of <code>oh-my-zsh</code> for several years, <code>zsh</code> is not a ubiquity shell, but since I&rsquo;ve decided to give up
on the &ldquo;use-everywhere&rdquo; feature, it&rsquo;s not a problem anymore. After one-week experience with <code>oh-my-zsh</code>, there&rsquo;re
several points I&rsquo;ve noticed:</p><ol><li>The basic <code>shell</code> support is similar, which makes porting the old <code>.bash_profile</code> very easy.</li><li>The default configuration of <code>oh-my-zsh</code> is good enough, so I don&rsquo;t have to worry about the initial learning curve.</li><li>The ecosystem (mainly plugins) was a key to success.</li><li>The <code>vi-mode</code> plugin works great, as a heavy user of <code>vim</code>, this boosts my keystrokes a lot.</li><li>Support <code>django</code> by default, and I&rsquo;m learning it to build a backend API server for my personal project.</li><li>History is synchronized across different terminals, especially useful as I&rsquo;m always using a lot of tabs for different purposes.</li></ol><p>All of these advantages make <code>oh-my-zsh</code> a safe suggestion for newbie programmers. It&rsquo;s neither exotic nor bizarre,
it&rsquo;s a decent good starting point and everything you learned with it will be useful later.</p><h2 id=some-pain-points-as-a-former-bash-user>Some pain points as a former bash user<a hidden class=anchor aria-hidden=true href=#some-pain-points-as-a-former-bash-user>#</a></h2><ol><li><code>git</code> plugin shiped by default pollutes the command line with a super long list of <code>git</code> shortcuts, as a heavy user of <code>.gitconfig</code>,
it&rsquo;s useless and confusing.</li><li><code>git</code> has a default integration with <code>oh-my-zsh</code>, you need to turn it off. First noticed this when I <code>cd</code> into the
WebKit repository and <code>zsh</code> were stuck on it.</li><li>The completion doesn&rsquo;t always work, many packages don&rsquo;t ship with zsh completion by default.</li><li>The <code>tab</code> behavior feels very different from <code>bash</code>, I&rsquo;m still getting used to it.</li><li>History across terminals is good, but also a bit confusing when I stoke <code>up</code> and see something unexpected.</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.kassiansun.com/tags/development/>Development</a></li><li><a href=https://blog.kassiansun.com/tags/terminal/>Terminal</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.kassiansun.com/>Kassian Sun</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>