<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go Runtime Implementations: Stack and Memory Management | Kassian Sun</title><meta name=keywords content="go"><meta name=description content="Stack Management Code Path: src/runtime/stack.go Stack pools are initialized before mheap_, because we don&rsquo;t allocate any memory during this stage. Right after the stack pools initialized, the mheap_ will be initialized so later stack allocation is possible.
stackpool stackpool is managed by the &ldquo;order&rdquo; (based on the ratio of stack size and _FixedStack) of the stack, each order of stack has its own stack pool. In stackinit, the stack pool will be initialized right after moduledataverify."><meta name=author content><link rel=canonical href=https://kassiansun.github.io/posts/go-source-code-part-10/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kassiansun.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kassiansun.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kassiansun.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://kassiansun.github.io/apple-touch-icon.png><link rel=mask-icon href=https://kassiansun.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-E9FSQ1R0HV"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-E9FSQ1R0HV",{anonymize_ip:!1})}</script><meta property="og:title" content="Go Runtime Implementations: Stack and Memory Management"><meta property="og:description" content="Stack Management Code Path: src/runtime/stack.go Stack pools are initialized before mheap_, because we don&rsquo;t allocate any memory during this stage. Right after the stack pools initialized, the mheap_ will be initialized so later stack allocation is possible.
stackpool stackpool is managed by the &ldquo;order&rdquo; (based on the ratio of stack size and _FixedStack) of the stack, each order of stack has its own stack pool. In stackinit, the stack pool will be initialized right after moduledataverify."><meta property="og:type" content="article"><meta property="og:url" content="https://kassiansun.github.io/posts/go-source-code-part-10/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-16T15:48:13+08:00"><meta property="article:modified_time" content="2022-10-16T15:48:13+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go Runtime Implementations: Stack and Memory Management"><meta name=twitter:description content="Stack Management Code Path: src/runtime/stack.go Stack pools are initialized before mheap_, because we don&rsquo;t allocate any memory during this stage. Right after the stack pools initialized, the mheap_ will be initialized so later stack allocation is possible.
stackpool stackpool is managed by the &ldquo;order&rdquo; (based on the ratio of stack size and _FixedStack) of the stack, each order of stack has its own stack pool. In stackinit, the stack pool will be initialized right after moduledataverify."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kassiansun.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Go Runtime Implementations: Stack and Memory Management","item":"https://kassiansun.github.io/posts/go-source-code-part-10/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go Runtime Implementations: Stack and Memory Management","name":"Go Runtime Implementations: Stack and Memory Management","description":"Stack Management Code Path: src/runtime/stack.go Stack pools are initialized before mheap_, because we don\u0026rsquo;t allocate any memory during this stage. Right after the stack pools initialized, the mheap_ will be initialized so later stack allocation is possible.\nstackpool stackpool is managed by the \u0026ldquo;order\u0026rdquo; (based on the ratio of stack size and _FixedStack) of the stack, each order of stack has its own stack pool. In stackinit, the stack pool will be initialized right after moduledataverify.","keywords":["go"],"articleBody":"Stack Management Code Path: src/runtime/stack.go Stack pools are initialized before mheap_, because we don’t allocate any memory during this stage. Right after the stack pools initialized, the mheap_ will be initialized so later stack allocation is possible.\nstackpool stackpool is managed by the “order” (based on the ratio of stack size and _FixedStack) of the stack, each order of stack has its own stack pool. In stackinit, the stack pool will be initialized right after moduledataverify.\nEach stack pool item is a list of mspan, recording the start address of the memory zone and the number of pages allocated.\nstackLarge stackLarge is similar to stackpool, but managed by log2(number of pages).\nstackalloc All go stacks will be allocated by stackalloc. It will return a new stack structure tracking the low and high of the stack address. stackalloc must be called by g0.\nAllocate small stacks from the global stackpool or m’s own stack cache. Allocate large stacks from stackLarge, or manually by mheap.allocManual stackfree stackfree will not return the memory to the OS, instead, it just puts the memory back to stackpool or stackLarge.\nMemory Management with mheap Code Path: src/runtime/mheap.go mheap_ is an instance of mheap struct, which serves as the main malloc heap.\nmSpanList It’s not a red-black tree, so querying a free zone is done by iterating through the list with a hint index freeindex. Other fields are for the GC process.\nmheap.alloc and mheap.allocManual The difference is alloc will try to mheap.reclaim the required number of pages, allocManual won’t. The underlying allocation strategies are handled by mheap.allocSpan and controlled by spanAllocType.\nmheap.allocSpan allocSpan is the main function to allocate a mspan\nTry to get from the small allocation from the page cache first (each p has its own page cache). This cache can be accessed without locking. If there’s no cache, allocate a new one with pageAlloc.allocToCache. Try to get a mspan from p.mspancache. Try to find a free region by pageAlloc.find. Calculate the extraPages to align the physical page. If not found, grow the heap by mheap.grow, and find again. Align up the base address, and mark the region as allocated. If it doesn’t need physical page alignment, the allocation flow is different: Try pageAlloc.alloc. If failed, grow the heap and pageAlloc.alloc again. Allocate a new mspan. Initialize the span with allocate base address. Check whether it needs to zero the allocated mspan. Initialize the mark and allocation structures if it’s a heap allocation. Not for allocManual. Do the memory scavenge. mheap.grow grow will allocate a new memory region from the OS, and track the region internally.\npageAlloc Code Path: src/runtime/mpagealloc.go pageAlloc is the main data structure to manage the pages.\npageAlloc.alloc alloc will first try to find a chunk from the radix tree directly, then fallback to pageAlloc.find.\npageAlloc.find find search the radix tree to find a contiguous memory region.\npageAlloc.scavenge Code Path: src/runtime/mgcscavenge.go scavenge is used to return the physical page back to the OS.\npageCache Code Path: src/runtime/mpagecache.go pageCache is a per-p cache of pages, used for small allocations.\npageAlloc.allocToCache allocToCache gets a new page cache for p.\npageCache.alloc ","wordCount":"517","inLanguage":"en","datePublished":"2022-10-16T15:48:13+08:00","dateModified":"2022-10-16T15:48:13+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://kassiansun.github.io/posts/go-source-code-part-10/"},"publisher":{"@type":"Organization","name":"Kassian Sun","logo":{"@type":"ImageObject","url":"https://kassiansun.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kassiansun.github.io/ accesskey=h title="Kassian Sun (Alt + H)">Kassian Sun</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kassiansun.github.io/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Go Runtime Implementations: Stack and Memory Management</h1><div class=post-meta><span title='2022-10-16 15:48:13 +0800 +0800'>October 16, 2022</span></div></header><div class=post-content><h2 id=stack-management>Stack Management<a hidden class=anchor aria-hidden=true href=#stack-management>#</a></h2><ul><li>Code Path: <code>src/runtime/stack.go</code></li></ul><p>Stack pools are initialized before <code>mheap_</code>, because we don&rsquo;t allocate any memory during this stage.
Right after the stack pools initialized, the <code>mheap_</code> will be initialized so later stack allocation is possible.</p><h3 id=stackpool><code>stackpool</code><a hidden class=anchor aria-hidden=true href=#stackpool>#</a></h3><p><code>stackpool</code> is managed by the &ldquo;order&rdquo; (based on the ratio of stack size and <code>_FixedStack</code>) of the stack, each order of stack has its own stack pool.
In <code>stackinit</code>, the stack pool will be initialized right after <code>moduledataverify</code>.</p><p>Each stack pool item is a list of <code>mspan</code>, recording the start address of the memory zone and the number of pages allocated.</p><h3 id=stacklarge><code>stackLarge</code><a hidden class=anchor aria-hidden=true href=#stacklarge>#</a></h3><p><code>stackLarge</code> is similar to <code>stackpool</code>, but managed by log2(number of pages).</p><h3 id=stackalloc><code>stackalloc</code><a hidden class=anchor aria-hidden=true href=#stackalloc>#</a></h3><p>All <code>go</code> stacks will be allocated by <code>stackalloc</code>. It will return a new <code>stack</code> structure tracking the low and high of the stack address.
<code>stackalloc</code> must be called by <code>g0</code>.</p><ul><li>Allocate small stacks from the global <code>stackpool</code> or <code>m</code>&rsquo;s own stack cache.</li><li>Allocate large stacks from <code>stackLarge</code>, or manually by <code>mheap.allocManual</code></li></ul><h3 id=stackfree><code>stackfree</code><a hidden class=anchor aria-hidden=true href=#stackfree>#</a></h3><p><code>stackfree</code> will not return the memory to the OS, instead, it just puts the memory back to <code>stackpool</code> or <code>stackLarge</code>.</p><h2 id=memory-management-with-mheap>Memory Management with <code>mheap</code><a hidden class=anchor aria-hidden=true href=#memory-management-with-mheap>#</a></h2><ul><li>Code Path: <code>src/runtime/mheap.go</code></li></ul><p><code>mheap_</code> is an instance of <code>mheap</code> struct, which serves as the main malloc heap.</p><h3 id=mspanlist><code>mSpanList</code><a hidden class=anchor aria-hidden=true href=#mspanlist>#</a></h3><p>It&rsquo;s not a red-black tree, so querying a free zone is done by iterating through the list with a hint index <code>freeindex</code>.
Other fields are for the GC process.</p><h3 id=mheapalloc-and-mheapallocmanual><code>mheap.alloc</code> and <code>mheap.allocManual</code><a hidden class=anchor aria-hidden=true href=#mheapalloc-and-mheapallocmanual>#</a></h3><p>The difference is <code>alloc</code> will try to <code>mheap.reclaim</code> the required number of pages, <code>allocManual</code> won&rsquo;t.
The underlying allocation strategies are handled by <code>mheap.allocSpan</code> and controlled by <code>spanAllocType</code>.</p><h3 id=mheapallocspan><code>mheap.allocSpan</code><a hidden class=anchor aria-hidden=true href=#mheapallocspan>#</a></h3><p><code>allocSpan</code> is the main function to allocate a <code>mspan</code></p><ul><li>Try to get from the small allocation from the page cache first (each <code>p</code> has its own page cache). This cache can be accessed without locking.<ul><li>If there&rsquo;s no cache, allocate a new one with <code>pageAlloc.allocToCache</code>.</li></ul></li><li>Try to get a mspan from <code>p.mspancache</code>.</li><li>Try to find a free region by <code>pageAlloc.find</code>.<ul><li>Calculate the <code>extraPages</code> to align the physical page.</li><li>If not found, grow the heap by <code>mheap.grow</code>, and find again.</li><li>Align up the base address, and mark the region as allocated.</li></ul></li><li>If it doesn&rsquo;t need physical page alignment, the allocation flow is different:<ul><li>Try <code>pageAlloc.alloc</code>.</li><li>If failed, grow the heap and <code>pageAlloc.alloc</code> again.</li></ul></li><li>Allocate a new <code>mspan</code>.</li><li>Initialize the <code>span</code> with allocate base address.</li><li>Check whether it needs to zero the allocated <code>mspan</code>.</li><li>Initialize the mark and allocation structures if it&rsquo;s a heap allocation. Not for <code>allocManual</code>.</li><li>Do the memory scavenge.</li></ul><h3 id=mheapgrow><code>mheap.grow</code><a hidden class=anchor aria-hidden=true href=#mheapgrow>#</a></h3><p><code>grow</code> will allocate a new memory region from the OS, and track the region internally.</p><h2 id=pagealloc><code>pageAlloc</code><a hidden class=anchor aria-hidden=true href=#pagealloc>#</a></h2><ul><li>Code Path: <code>src/runtime/mpagealloc.go</code></li></ul><p><code>pageAlloc</code> is the main data structure to manage the pages.</p><h3 id=pageallocalloc><code>pageAlloc.alloc</code><a hidden class=anchor aria-hidden=true href=#pageallocalloc>#</a></h3><p><code>alloc</code> will first try to find a chunk from the radix tree directly, then fallback to <code>pageAlloc.find</code>.</p><h3 id=pageallocfind><code>pageAlloc.find</code><a hidden class=anchor aria-hidden=true href=#pageallocfind>#</a></h3><p><code>find</code> search the radix tree to find a contiguous memory region.</p><h3 id=pageallocscavenge><code>pageAlloc.scavenge</code><a hidden class=anchor aria-hidden=true href=#pageallocscavenge>#</a></h3><ul><li>Code Path: <code>src/runtime/mgcscavenge.go</code></li></ul><p><code>scavenge</code> is used to return the physical page back to the OS.</p><h2 id=pagecache><code>pageCache</code><a hidden class=anchor aria-hidden=true href=#pagecache>#</a></h2><ul><li>Code Path: <code>src/runtime/mpagecache.go</code></li></ul><p><code>pageCache</code> is a per-<code>p</code> cache of pages, used for small allocations.</p><h3 id=pageallocalloctocache><code>pageAlloc.allocToCache</code><a hidden class=anchor aria-hidden=true href=#pageallocalloctocache>#</a></h3><p><code>allocToCache</code> gets a new page cache for <code>p</code>.</p><h3 id=pagecachealloc><code>pageCache.alloc</code><a hidden class=anchor aria-hidden=true href=#pagecachealloc>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://kassiansun.github.io/tags/go/>go</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://kassiansun.github.io/>Kassian Sun</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>