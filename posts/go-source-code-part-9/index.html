<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go Runtime Implementations: Scheduling | Kassian Sun</title>
<meta name=keywords content="go"><meta name=description content="Code Path: src/runtime/proc.go Start-Up Process of a Go program. Take src/runtime/asm_arm.s as an example:
Take the address of g0 and m0. Set up m.g0 and g.m. Create istack. Do runtime check. Save argc and argv. Call runtime.osinit. Call runtime.schedinit. Call runtime.newproc for the main function. call runtime.mstart to start the M. runtime.osinit Take src/runtime/os_linux.go as an example:
Get the number of processors. This is done by making a syscall SYS_sched_getaffinity."><meta name=author content><link rel=canonical href=https://blog.kassiansun.com/posts/go-source-code-part-9/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.kassiansun.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.kassiansun.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.kassiansun.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.kassiansun.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.kassiansun.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.kassiansun.com/posts/go-source-code-part-9/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-E9FSQ1R0HV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-E9FSQ1R0HV")}</script><meta property="og:title" content="Go Runtime Implementations: Scheduling"><meta property="og:description" content="Code Path: src/runtime/proc.go Start-Up Process of a Go program. Take src/runtime/asm_arm.s as an example:
Take the address of g0 and m0. Set up m.g0 and g.m. Create istack. Do runtime check. Save argc and argv. Call runtime.osinit. Call runtime.schedinit. Call runtime.newproc for the main function. call runtime.mstart to start the M. runtime.osinit Take src/runtime/os_linux.go as an example:
Get the number of processors. This is done by making a syscall SYS_sched_getaffinity."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.kassiansun.com/posts/go-source-code-part-9/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-14T18:31:51+08:00"><meta property="article:modified_time" content="2022-10-14T18:31:51+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go Runtime Implementations: Scheduling"><meta name=twitter:description content="Code Path: src/runtime/proc.go Start-Up Process of a Go program. Take src/runtime/asm_arm.s as an example:
Take the address of g0 and m0. Set up m.g0 and g.m. Create istack. Do runtime check. Save argc and argv. Call runtime.osinit. Call runtime.schedinit. Call runtime.newproc for the main function. call runtime.mstart to start the M. runtime.osinit Take src/runtime/os_linux.go as an example:
Get the number of processors. This is done by making a syscall SYS_sched_getaffinity."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.kassiansun.com/posts/"},{"@type":"ListItem","position":2,"name":"Go Runtime Implementations: Scheduling","item":"https://blog.kassiansun.com/posts/go-source-code-part-9/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go Runtime Implementations: Scheduling","name":"Go Runtime Implementations: Scheduling","description":"Code Path: src/runtime/proc.go Start-Up Process of a Go program. Take src/runtime/asm_arm.s as an example:\nTake the address of g0 and m0. Set up m.g0 and g.m. Create istack. Do runtime check. Save argc and argv. Call runtime.osinit. Call runtime.schedinit. Call runtime.newproc for the main function. call runtime.mstart to start the M. runtime.osinit Take src/runtime/os_linux.go as an example:\nGet the number of processors. This is done by making a syscall SYS_sched_getaffinity.","keywords":["go"],"articleBody":" Code Path: src/runtime/proc.go Start-Up Process of a Go program. Take src/runtime/asm_arm.s as an example:\nTake the address of g0 and m0. Set up m.g0 and g.m. Create istack. Do runtime check. Save argc and argv. Call runtime.osinit. Call runtime.schedinit. Call runtime.newproc for the main function. call runtime.mstart to start the M. runtime.osinit Take src/runtime/os_linux.go as an example:\nGet the number of processors. This is done by making a syscall SYS_sched_getaffinity. Get the huge page size. Run osArchInit. \u003c- Seems not used. runtime.schedinit Initialize all the locks. Set up the g.racectx. Stop the world. moduledataverify. Defined in src/runtime/symtab.go, it will check moduledata’s binary info. stackinit. Defined in src/runtime/stack.go, it will setup the global stack pool, all stacks will be allocated by it. mallocinit. Defined in src/runtime/malloc.go, it will initialize the memory allocator used by Go. cpuinit. Set up the internal/cpu information. alginit. Defined in src/runtime/alg.go, set up the CPU instructions that will be used by some internal algorithms, depending on cpuinit. fastrandinit. Initialize the g0.m with mcommoninit. modulesinit. Defined in src/runtime/symtab.go, initialize the dynamic loaded modules. typelinksinit. Defined in src/runtime/type.go, initialized the dynamic-loaded module type informations. itabsinit. Defined in src/runtime/iface.go, update itabTable with the dynamic-loaded modules. stkobjinit. Defined in src/runtime/stkframe.go, this will set up methodValueCallFrameObjs, used by later GC module. Save the signal mask as initSigMask. Parse argv. Defined in src/runtime/runtime1.go. Parse environment variables. parsedebugvars. Defined in src/runtime/runtime1.go. gcinit. Set up the number of processors, and trim it accordingly with procresize: Grow allp as necessary. Initialize all the p’s of allp. Release old p’s. Track the idle and runnable p, and return the runnable p’s. There should be zero runnable p, since this is only a bootstrap process. Start the world. runtime.mstart mstart0 set up the stack info, then calls runtime.mstart1 to allocate the m:\nCheck whether the current g is m’s scheduling g0. Set up the m.g0, mostly the same as newproc. Init the assembly part with asminit, ISA-dependent. Init the thread-level information with minit, OS-dependent. If the current m is m0, spin up an extra m, and initialize signals. Call m.mstartfn. If it’s not m0, acquire the m’s p. schedule(). Start a New Goroutine: runtime.newproc In Go, you start a goroutine with the go keyword, this compiler will expand this keyword as runtime.newproc.\ngetg to fetch the curreng g information. getcallerpc to fetch the pc register of the caller. This function is expanded to assembly code by the compiler as ssa.OpGetCallerPC. Run the goroutine from systemstack. systemstack is used to run the function with a goroutine stack. acquirem to get the m of current g. Get a free g from p. First check the p.gFree, if empty, try to get from the global sched.gFree. Pop a free g from p.gFree. Clear the g’s old stack and allocate a new stack for it. If there’s no free g allocated before, allocate a new one. Create a new g. Allocate the memory for system stack size + desired stack size. Change the g status to _Gdead. Add the new g to the global allgs list. Reserve some extra memory at the top of the stack, and shift sp register accordingly. Set up the g.sched. It contains sp, pc, and the new g’s address. Set up the g.sched, and get ready for the actual function call. Save the caller’s pc into g.gopc. Save the ancestor info into g.ancestors. Track the profiling information for system and user-defined goroutines separately. Switch g status to _Grunnable. Track the stack at GC. Generate g.goid. Put the g on the runnable queue. Try to add more p to execute g. runtime.wakep wakep is called at the last step of newproc, tring to run the _Grunnable g. This step will make sure that there’s always a spinning m ready to run the new g.\nIf there’s already a spinning p, return immediately. Lock the current m. Try to get a spinning p. Start a new m to hold the p. Scheduling Cycle: runtime.schedule Callers: mstart0, gopark, goschedguarded/gopreempt_m, preemptPark, goyield, goexit1, exitsyscall.\nLet’s try to analyze these callers one by one.\nruntime.mstart0 See above.\nruntime.goschedImpl It’s a common function to schedule a goroutine:\nCheck g status is _Grunning. Change g status to _Grunnable. Detach g from the current m. Put g onto the global run queue. schedule(). runtime.gopark See the last post.\nruntime.gopreempt_m, runtime.goschedguarded These are wrappers around goschedImpl.\nruntime.preemptPark This function is similar to goschedImpl, but switches the g status to _Gpreempted.\nruntime.goyield This function is similar to goschedImpl, but without the _Grunning check, because it’s called from the current goroutine to yield the current m.\nruntime.goexit1 goexit1 will finish the current goroutine.\nChange the status to _Gdead. Release all g’s resources. Detach g from the current m. Put g on the free list. If the g is locked, kill the thread directly. schedule(). runtime.exitsyscall exitsyscall will only be called by syscalls, after the syscall is finished, it will call this function to switch back to the goroutine.\nTry to acquire the old p or get one idle p. If acquired, no need to do anything, just return immediately. If the old p is still _Psyscall, switch to _Pidle and attach g to this p. Get a p from the global idle p list, and attach g to this p. Switch the g status to _Grunning. Update g status to _Grunnable. Detach g from the m. If g can be scheduled, try to get an idle p. If there’s no idle p: Put g on the global runnable queue. If it’s locked, startlockedm: Stop the locked m of the current g if necessary. The current executing g on that m will be handed off to others. Execute g. Else: Stop the m and wait for an available p. schedule(). Else: Notify sysmon if necessary. Attach g to the p and run it. Execute g. The implementation of runtime.schedule If the g is locked, stop that m and run g on that m. No scheduling in this part. CGO is always handled in g0, so it should never call the schedule(). Find a runnable g with findRunnable Wait for GC stop-the-world. Get the timer information from the current p. Try to schedule a trace reader. Try to schedule a GC worker. Get one g from the global runnable queue. Run it regularly but not on every cycle to ensure fairness. Mark GC finblock’s as ready. If there’s a cgo_yield, run it. Get one g from the local runnable queue. Get one g from the global runnable queue. Poll the network. Steal the work from other p’s. There’s nothing to do: Run GC marking worker. Put back p to the global idle list. Poll the network. Stop the current m. Try it again until find a g. Reset the spinning m. Wake up a p for internal goroutines (GC workers, etc). If the g is locked to an m, run startlockedm. Execute g. What’s Next Go’s memory allocator. Go’s stack allocator. ","wordCount":"1151","inLanguage":"en","datePublished":"2022-10-14T18:31:51+08:00","dateModified":"2022-10-14T18:31:51+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.kassiansun.com/posts/go-source-code-part-9/"},"publisher":{"@type":"Organization","name":"Kassian Sun","logo":{"@type":"ImageObject","url":"https://blog.kassiansun.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.kassiansun.com/ accesskey=h title="Kassian Sun (Alt + H)">Kassian Sun</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.kassiansun.com/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Go Runtime Implementations: Scheduling</h1><div class=post-meta><span title='2022-10-14 18:31:51 +0800 +0800'>October 14, 2022</span></div></header><div class=post-content><ul><li>Code Path: <code>src/runtime/proc.go</code></li></ul><h2 id=start-up-process-of-a-go-program>Start-Up Process of a Go program.<a hidden class=anchor aria-hidden=true href=#start-up-process-of-a-go-program>#</a></h2><p>Take <code>src/runtime/asm_arm.s</code> as an example:</p><ul><li>Take the address of <code>g0</code> and <code>m0</code>.</li><li>Set up <code>m.g0</code> and <code>g.m</code>.</li><li>Create <code>istack</code>.</li><li>Do runtime check.</li><li>Save <code>argc</code> and <code>argv</code>.</li><li>Call <code>runtime.osinit</code>.</li><li>Call <code>runtime.schedinit</code>.</li><li>Call <code>runtime.newproc</code> for the main function.</li><li>call <code>runtime.mstart</code> to start the M.</li></ul><h3 id=runtimeosinit><code>runtime.osinit</code><a hidden class=anchor aria-hidden=true href=#runtimeosinit>#</a></h3><p>Take <code>src/runtime/os_linux.go</code> as an example:</p><ul><li>Get the number of processors. This is done by making a syscall <code>SYS_sched_getaffinity</code>.</li><li>Get the huge page size.</li><li>Run osArchInit. &lt;- Seems not used.</li></ul><h3 id=runtimeschedinit><code>runtime.schedinit</code><a hidden class=anchor aria-hidden=true href=#runtimeschedinit>#</a></h3><ul><li>Initialize all the locks.</li><li>Set up the <code>g.racectx</code>.</li><li>Stop the world.</li><li><code>moduledataverify</code>. Defined in <code>src/runtime/symtab.go</code>, it will check <code>moduledata</code>&rsquo;s binary info.</li><li><code>stackinit</code>. Defined in <code>src/runtime/stack.go</code>, it will setup the global stack pool, all stacks will be allocated by it.</li><li><code>mallocinit</code>. Defined in <code>src/runtime/malloc.go</code>, it will initialize the memory allocator used by Go.</li><li><code>cpuinit</code>. Set up the <code>internal/cpu</code> information.</li><li><code>alginit</code>. Defined in <code>src/runtime/alg.go</code>, set up the CPU instructions that will be used by some internal algorithms, depending on <code>cpuinit</code>.</li><li><code>fastrandinit</code>.</li><li>Initialize the <code>g0.m</code> with <code>mcommoninit</code>.</li><li><code>modulesinit</code>. Defined in <code>src/runtime/symtab.go</code>, initialize the dynamic loaded modules.</li><li><code>typelinksinit</code>. Defined in <code>src/runtime/type.go</code>, initialized the dynamic-loaded module type informations.</li><li><code>itabsinit</code>. Defined in <code>src/runtime/iface.go</code>, update <code>itabTable</code> with the dynamic-loaded modules.</li><li><code>stkobjinit</code>. Defined in <code>src/runtime/stkframe.go</code>, this will set up <code>methodValueCallFrameObjs</code>, used by later GC module.</li><li>Save the signal mask as <code>initSigMask</code>.</li><li>Parse <code>argv</code>. Defined in <code>src/runtime/runtime1.go</code>.</li><li>Parse environment variables.</li><li><code>parsedebugvars</code>. Defined in <code>src/runtime/runtime1.go</code>.</li><li><code>gcinit</code>.</li><li>Set up the number of processors, and trim it accordingly with <code>procresize</code>:<ul><li>Grow <code>allp</code> as necessary.</li><li>Initialize all the <code>p</code>&rsquo;s of <code>allp</code>.</li><li>Release old <code>p</code>&rsquo;s.</li><li>Track the idle and runnable <code>p</code>, and return the runnable <code>p</code>&rsquo;s.</li></ul></li><li>There should be zero runnable <code>p</code>, since this is only a bootstrap process.</li><li>Start the world.</li></ul><h3 id=runtimemstart><code>runtime.mstart</code><a hidden class=anchor aria-hidden=true href=#runtimemstart>#</a></h3><p><code>mstart0</code> set up the stack info, then calls <code>runtime.mstart1</code> to allocate the m:</p><ul><li>Check whether the current <code>g</code> is <code>m</code>&rsquo;s scheduling <code>g0</code>.</li><li>Set up the <code>m.g0</code>, mostly the same as <code>newproc</code>.</li><li>Init the assembly part with <code>asminit</code>, ISA-dependent.</li><li>Init the thread-level information with <code>minit</code>, OS-dependent.</li><li>If the current <code>m</code> is <code>m0</code>, spin up an extra <code>m</code>, and initialize signals.</li><li>Call <code>m.mstartfn</code>.</li><li>If it&rsquo;s not <code>m0</code>, acquire the <code>m</code>&rsquo;s p.</li><li><code>schedule()</code>.</li></ul><h2 id=start-a-new-goroutine-runtimenewproc>Start a New Goroutine: <code>runtime.newproc</code><a hidden class=anchor aria-hidden=true href=#start-a-new-goroutine-runtimenewproc>#</a></h2><p>In Go, you start a goroutine with the <code>go</code> keyword, this compiler will expand this keyword as <code>runtime.newproc</code>.</p><ul><li><code>getg</code> to fetch the curreng <code>g</code> information.</li><li><code>getcallerpc</code> to fetch the pc register of the caller. This function is expanded to assembly code by the compiler as <code>ssa.OpGetCallerPC</code>.</li><li>Run the goroutine from <code>systemstack</code>. <code>systemstack</code> is used to run the function with a goroutine stack.</li><li><code>acquirem</code> to get the <code>m</code> of current <code>g</code>.</li><li>Get a free <code>g</code> from <code>p</code>.<ul><li>First check the <code>p.gFree</code>, if empty, try to get from the global <code>sched.gFree</code>.</li><li>Pop a free <code>g</code> from <code>p.gFree</code>.</li><li>Clear the <code>g</code>&rsquo;s old stack and allocate a new stack for it.</li></ul></li><li>If there&rsquo;s no free <code>g</code> allocated before, allocate a new one.<ul><li>Create a new <code>g</code>.</li><li>Allocate the memory for system stack size + desired stack size.</li><li>Change the <code>g</code> status to <code>_Gdead</code>.</li><li>Add the new <code>g</code> to the global <code>allgs</code> list.</li></ul></li><li>Reserve some extra memory at the top of the stack, and shift <code>sp</code> register accordingly.</li><li>Set up the <code>g.sched</code>. It contains <code>sp</code>, <code>pc</code>, and the new <code>g</code>&rsquo;s address.</li><li>Set up the <code>g.sched</code>, and get ready for the actual function call.</li><li>Save the caller&rsquo;s pc into <code>g.gopc</code>.</li><li>Save the ancestor info into <code>g.ancestors</code>.</li><li>Track the profiling information for system and user-defined goroutines separately.</li><li>Switch <code>g</code> status to <code>_Grunnable</code>.</li><li>Track the stack at GC.</li><li>Generate <code>g.goid</code>.</li><li>Put the <code>g</code> on the runnable queue.</li><li>Try to add more <code>p</code> to execute <code>g</code>.</li></ul><h3 id=runtimewakep><code>runtime.wakep</code><a hidden class=anchor aria-hidden=true href=#runtimewakep>#</a></h3><p><code>wakep</code> is called at the last step of <code>newproc</code>, tring to run the <code>_Grunnable</code> <code>g</code>. This step will make sure that there&rsquo;s always a spinning <code>m</code> ready to run the new <code>g</code>.</p><ul><li>If there&rsquo;s already a spinning <code>p</code>, return immediately.</li><li>Lock the current <code>m</code>.</li><li>Try to get a spinning <code>p</code>.</li><li>Start a new <code>m</code> to hold the <code>p</code>.</li></ul><h2 id=scheduling-cycle-runtimeschedule>Scheduling Cycle: <code>runtime.schedule</code><a hidden class=anchor aria-hidden=true href=#scheduling-cycle-runtimeschedule>#</a></h2><p>Callers: <code>mstart0</code>, <code>gopark</code>, <code>goschedguarded/gopreempt_m</code>, <code>preemptPark</code>, <code>goyield</code>, <code>goexit1</code>, <code>exitsyscall</code>.</p><p>Let&rsquo;s try to analyze these callers one by one.</p><h3 id=runtimemstart0><code>runtime.mstart0</code><a hidden class=anchor aria-hidden=true href=#runtimemstart0>#</a></h3><p>See above.</p><h3 id=runtimegoschedimpl><code>runtime.goschedImpl</code><a hidden class=anchor aria-hidden=true href=#runtimegoschedimpl>#</a></h3><p>It&rsquo;s a common function to schedule a goroutine:</p><ul><li>Check <code>g</code> status is <code>_Grunning</code>.</li><li>Change <code>g</code> status to <code>_Grunnable</code>.</li><li>Detach <code>g</code> from the current <code>m</code>.</li><li>Put <code>g</code> onto the global run queue.</li><li><code>schedule()</code>.</li></ul><h3 id=runtimegopark><code>runtime.gopark</code><a hidden class=anchor aria-hidden=true href=#runtimegopark>#</a></h3><p>See the <a href=/posts/go-source-code-part-8/>last post</a>.</p><h3 id=runtimegopreempt_m-runtimegoschedguarded><code>runtime.gopreempt_m</code>, <code>runtime.goschedguarded</code><a hidden class=anchor aria-hidden=true href=#runtimegopreempt_m-runtimegoschedguarded>#</a></h3><p>These are wrappers around <code>goschedImpl</code>.</p><h3 id=runtimepreemptpark><code>runtime.preemptPark</code><a hidden class=anchor aria-hidden=true href=#runtimepreemptpark>#</a></h3><p>This function is similar to <code>goschedImpl</code>, but switches the <code>g</code> status to <code>_Gpreempted</code>.</p><h3 id=runtimegoyield><code>runtime.goyield</code><a hidden class=anchor aria-hidden=true href=#runtimegoyield>#</a></h3><p>This function is similar to <code>goschedImpl</code>, but without the <code>_Grunning</code> check, because it&rsquo;s called from the current goroutine to yield the current <code>m</code>.</p><h3 id=runtimegoexit1><code>runtime.goexit1</code><a hidden class=anchor aria-hidden=true href=#runtimegoexit1>#</a></h3><p><code>goexit1</code> will finish the current goroutine.</p><ul><li>Change the status to <code>_Gdead</code>.</li><li>Release all <code>g</code>&rsquo;s resources.</li><li>Detach <code>g</code> from the current <code>m</code>.</li><li>Put <code>g</code> on the free list.</li><li>If the <code>g</code> is locked, kill the thread directly.</li><li><code>schedule()</code>.</li></ul><h3 id=runtimeexitsyscall><code>runtime.exitsyscall</code><a hidden class=anchor aria-hidden=true href=#runtimeexitsyscall>#</a></h3><p><code>exitsyscall</code> will only be called by syscalls, after the syscall is finished, it will call this function to switch back to the goroutine.</p><ul><li>Try to acquire the old <code>p</code> or get one idle <code>p</code>. If acquired, no need to do anything, just return immediately.<ul><li>If the old <code>p</code> is still <code>_Psyscall</code>, switch to <code>_Pidle</code> and attach <code>g</code> to this <code>p</code>.</li><li>Get a <code>p</code> from the global idle <code>p</code> list, and attach <code>g</code> to this <code>p</code>.</li><li>Switch the <code>g</code> status to <code>_Grunning</code>.</li></ul></li><li>Update <code>g</code> status to <code>_Grunnable</code>.</li><li>Detach <code>g</code> from the <code>m</code>.</li><li>If <code>g</code> can be scheduled, try to get an idle <code>p</code>.</li><li>If there&rsquo;s no idle <code>p</code>:<ul><li>Put <code>g</code> on the global runnable queue.</li><li>If it&rsquo;s locked, <code>startlockedm</code>:<ul><li>Stop the locked <code>m</code> of the current <code>g</code> if necessary. The current executing <code>g</code> on that <code>m</code> will be handed off to others.</li><li>Execute <code>g</code>.</li></ul></li><li>Else:<ul><li>Stop the m and wait for an available <code>p</code>.</li><li><code>schedule()</code>.</li></ul></li></ul></li><li>Else:<ul><li>Notify <code>sysmon</code> if necessary.</li><li>Attach <code>g</code> to the <code>p</code> and run it.</li><li>Execute <code>g</code>.</li></ul></li></ul><h3 id=the-implementation-of-runtimeschedule>The implementation of <code>runtime.schedule</code><a hidden class=anchor aria-hidden=true href=#the-implementation-of-runtimeschedule>#</a></h3><ul><li>If the <code>g</code> is locked, stop that <code>m</code> and run <code>g</code> on that <code>m</code>. No scheduling in this part.</li><li>CGO is always handled in <code>g0</code>, so it should never call the <code>schedule()</code>.</li><li>Find a runnable <code>g</code> with <code>findRunnable</code><ul><li>Wait for GC stop-the-world.</li><li>Get the timer information from the current <code>p</code>.</li><li>Try to schedule a trace reader.</li><li>Try to schedule a GC worker.</li><li>Get one <code>g</code> from the global runnable queue. Run it regularly but not on every cycle to ensure fairness.</li><li>Mark GC finblock&rsquo;s as ready.</li><li>If there&rsquo;s a <code>cgo_yield</code>, run it.</li><li>Get one <code>g</code> from the local runnable queue.</li><li>Get one <code>g</code> from the global runnable queue.</li><li>Poll the network.</li><li>Steal the work from other <code>p</code>&rsquo;s.</li><li>There&rsquo;s nothing to do:<ul><li>Run GC marking worker.</li><li>Put back <code>p</code> to the global idle list.</li><li>Poll the network.</li><li>Stop the current <code>m</code>.</li><li>Try it again until find a <code>g</code>.</li></ul></li></ul></li><li>Reset the spinning <code>m</code>.</li><li>Wake up a <code>p</code> for internal goroutines (GC workers, etc).</li><li>If the <code>g</code> is locked to an <code>m</code>, run <code>startlockedm</code>.</li><li>Execute <code>g</code>.</li></ul><h2 id=whats-next>What&rsquo;s Next<a hidden class=anchor aria-hidden=true href=#whats-next>#</a></h2><ul><li>Go&rsquo;s memory allocator.</li><li>Go&rsquo;s stack allocator.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.kassiansun.com/tags/go/>Go</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.kassiansun.com/>Kassian Sun</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>